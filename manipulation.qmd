# Data Manipulation

## Reading Data

R provides a number of ways to read data from a file, the **most flexible** of which is the `scan()` function. We use scan to read a vector of values from a file. It has the form:

*Example:*

``` r
scan(file = "", what = 0, n = -1, sep = "", skip = 0, quiet = FALSE)
```

`scan()` returns a vector.

### Tabular data

It is common for data to be arranged in **tables**, with columns corresponding to variables and rows corresponding to separate observations. These **dataframes** are usually read into R using the function `read.table()`, which has the form:

``` r
read.table(file, header = FALSE, sep = "") 
# read.table() returns a dataframe
```

There are two commonly used **variants** of `read.table()`:

-   `read.csv()` is for comma-separated data and is equivalent to `read.table(file, header = TRUE, sep = ",")`

-   `read.delim()` is for tab-delimited data and is equivalent to`read.table(file, header = TRUE, sep = "\t")`.

*Example:*

``` r
## skips the first 2 lines
anscombe <- read.csv("CSVanscombe.csv", skip=2) 
```

If a **.csv file** contains both numeric and character variables, and we use `read.csv()`, the character variables get automatically converted to the **factor** type. We can prevent character variables from this automatic conversion to factor, by specifying `stringsAsFactors=FALSE` within the `read.csv()` function.

*Example:*

``` r
iris_b <- read.csv("iris.csv", stringsAsFactors=F)
```

Sometimes, it could happen that the file extension is **.csv**, but the data is **not comma separated**. In that case, we can still use the `read.csv()` function, but in this case we have to specify the separator:

*Example:*

``` r
read.csv("iris_semicolon.csv", stringsAsFactors = FALSE, sep=";")
anscombe_tab_2 <- read.table("anscombe.txt", header=TRUE)
```

Note that you can assign your **own column names** after reading the dataframe using the `names()` function, or when you read it in, using the `col.names` argument, which should be assigned a character vector the same length as the number of columns. If there is no header and no col.names argument, then R uses the names "V1", "V2", etc.

After reading the file, you can use the `head()` and `tail()` functions to examine the object:

*Example:*

``` r
head(ufc)
tail()
```

### Read line by line

Text files can be **read line by line** using the `readLines()` function:

*Example:*

``` r
con <- gzfile("words.gz") 
x <- readLines(con, 10)
```

This approach is useful because it allows you to read from a file **without having to uncompress the file first**, which would be a waste of space and time.

To read in lines of **webpages** it can be useful the `readLines()` function:

*Example:*

``` r
con <- url("http://www.jhsph.edu", "r") ## Read the web page 
x <- readLines(con) ## Print out the first few lines head(x)
```

### xls format

If the dataset is stored in the ***.xls or*** **.xlsx format** you can use `read.xlsx2`:

*Example:*

``` r
library(xlsx) 
anscombe_xlsx <- read.xlsx2("xlsxanscombe.xlsx", sheetIndex=1)
```

### RData format

If you need to store more than one dataset in a single file we can use the **\*.RData format**:

*Example:*

``` r
## example to load multiple datasets, and a vector of R objects from a single *.RData
load("robjects.RData")
## to check if objects have been loaded correctly
objects()
```

### Import Stata/SPSS file

To import a **Stata/SPSS file** into R:

-   First you need to call the foreign library:

    ``` r
    install.packages("foreign")
    ```

-   Then use `read.data()`/`read.spss()`:

    ``` r
    data <- read.spss(file="data.spss", to.data.frame=TRUE)
    ```

-   The output will always be a data frame:

    ``` r
    write.foreign(data, "mydata.txt", "mydata.sps", package="SPSS")
    ```

### JSON File

To read a **JSON file**:

``` r
install.packages("rjson") 
data <- fromJSON(file="data.json")
data2 <- as.data.frame(data)
```

### `view()`

To view the data variable, you can use the `view()`.

## Writing Data

R provides a number of commands for **writing** output to a file. You will generally use `write()` or `write.table()` for writing numeric values and `cat()` for writing text, or a combination of numeric and character values.

The command `write()` has the form:

``` r
write(x, file = "data", ncolumns = if(is.character(x)) 1 else 5, append = FALSE)
```

To write a **dataframe** to a file we use this:

``` r
write.table(x, file = "", append = FALSE, sep = " ", row.names = TRUE, col.names = TRUE)
```

Here `x` is the vector to be written. If `x` is a **matrix or array** then it is converted to a vector (column by column) before being written. The other parameters are optional.

We can identify the **complete rows** from a two-dimensional object such as a dataframe (that is, rows that have no missing values) via the `complete.cases` command. We can easily remove rows with missing values using the `na.omit` function.

### Writing Matrices

Because `write()` converts matrices to vectors before writing them, using it to write a matrix to a file can cause unexpected results. Since R stores its matrices by column, you should pass the **transpose of the matrix to write** if you want the output to reflect the matrix structure.

``` r
x <- matrix(1:24, nrow = 4, ncol = 6)
write(t(x), file = "../results/out.txt", ncolumns = 6)
```

### `cat()`

A more flexible command for writing to a file is `cat()`, which has the form:

``` r
cat(..., file = "", sep = " ", append = FALSE)
```

Note that cat does not automatically write a newline after the expressions *....* If you want a newline you must explicitly include the string `\n`.

### Tabular Data

For **writing tabular data** to text files (i.e. CSV) or connections you may use `write.table()`, which has this format:

*Example:*

``` r
write.table()
```

### `dump()`

There is also the very useful `dump()` function, which creates a text representation of almost any R object that can subsequently be read by source.

*Example:*

``` r
x <- matrix(rep(1:5, 1:5), nrow = 3, ncol = 5)
dump("x", file = "../results/x.txt")
rm(x)
source("../results/x.txt")
x
```

## Subsetting R Objects

### `[` operator

The **`[` operator** always returns an object of the same class as the original:

```{r}
x <- c("a", "b", "c", "c", "d", "a")
# Extract the first element
x[1]
```

```{r}
# other examples
x[1:4]
x[c(1, 3, 49)]
```

```{r}
x <- 100:110
i <- c(1, 3 ,2)
x[i]
```

```{r}
u <- x > "a" 
x[u] ## or x[x > "a"]
```

-   Subsetting a **matrix**:

    ``` r
    x[1,2] ## Extract the first row, first column 
    x[1, ] ## Extract the first row 
    x[, 2] ## Extract the second column 
    x[1, 2, drop = FALSE] ## keeps the matrix format
    ```

-   It can be used to select **multiple elements** of an object (also in **lists** or **dataframes**):

    ```{r}
    (x <- list(foo = 1:4, bar = 0.6, baz = "hello"))
    x[c(1, 3)]
    x["foo"]
    class(x["foo"])
    x$foo[1]
    x$baz[1]
    ```

    ``` r
    ## use of negative subscript removes first element "3" 
    num10[-1]
    ```

### `[[` operator

The `[[` operator is used to extract elements of a **list or a dataframe**. It can only be used to extract a single element and the class of the returned object will not necessarily be a list or data frame.

-   **Subsetting a Dataframe**:

    ``` r
    # Use the notation [[ ]] to extract columns
    x[["var1"]] = x[, 1] = x$var1 # All are equivalent
    ```

-   **Subsetting a List**:

    ``` r
    x[[1]] ## Extract single element from a list 
    x[["bar"]] ## Extract named index
    x$bar ## Extract named index 
    x[[c(1, 3)]] ## Get the 3rd element of the 1st element of the list 
    x[[1]][[3]] ## Get the 3rd element of the 1st element of the list
    ```

-   Now if we want to get access to the **individual elements** of `list_obj[[2]]`, we have to use the following command:

    ```{r}
    (data_2variable <- data.frame(x1=c(2,3,4,5,6), x2=c(5,6,7,8,1)))
    (list_obj <- list(dat=data_2variable, vec.obj=c(1,2,3))) 
    list_obj[[2]][1]
    ```

### `$` operator

The **`$` operator** is used to extract elements of a **list or data frame by literal name**. Its semantics are similar to that of `[[`.

*Example:*

```{r}
x[["bar"]] ## Extract named index 
x$bar ## Extract named index
```

## Missing Values

R represents missing observations through the data value **NA**. It is easiest to think of **NA** values as place holders for data that should have been there, but, for some reason, are not.

### Detect NA

We can **detect** whether variables are missing value using:

-   `is.na()` is used to test objects if they are NA
-   `is.nan()` is used to test for NaN

*Example:*

```{r}
x <- c(1, 2, NaN, NA, 4) 
is.na(x) 
is.nan(x)
```

### Check if there is any **NA** in a data.frame:

*Example:*

```{r}
any(is.na(x))
```

### Remove NAs

*Example:*

```{r}
a <- c(11, NA, 13)
mean(a, na.rm = TRUE)
```

### Extract NA from a vector:

*Example:*

```{r 6}
x <- c(1, 2, NA, 3) 
z <- is.na(x) 
x[!z]
```

### NA vs NULL

Note that **NA** and **NULL** are not equivalent:

-   **NA** is a place holder for something that exists but is missing.

-   **NULL** stands for something that never existed at all.

## Removing NA values

You can remove rows with **NA** values in any variables:

``` r
na.omit(data)
```

```{r 7}
## Another example
x <- c(1, 2, NA, 4, NA, 5) 
bad <- is.na(x) 
x[!bad]
```

-   How to take the subset with no missing values in any of those objects?

``` r
good <- complete.cases(airquality) 
head(airquality[good,])
```

## Removing Duplicates

You can remove duplicates based on the x variable using:

``` r
x <- c(1, 2, NA, 4, NA, 5) 
data[!duplicated(data$x), ]
```

## Date Manipulation

In R, dates are stored as the number of days elapsed since **January 1, 1970**. The built-in R function `as.Date()` can handle only dates but not time. So if we convert any date object to its internal number, it will show the number of days.

We can reformat the number into a date using the date class.

```{r 8}
as.numeric(as.Date("1970-01-01")) ## We can also create a date object with other formats
as.numeric(as.Date("Jan-01-1970", format = "%b-%d-%Y"))
```

``` r
## For the complete list of code that is used to specify date formats
help(strptime)
```

The **chron package** can handle both date and time. However, it cannot work with time zones.

Using the **POSIXct** and **POSIXlt** class objects, we can work with time zones.

The **lubridate package** has a much more user-friendly functionality to process date and time, with time zone support:

-   It can process date variables in heterogeneous formats.
-   Note that the default time zone in the mdy, dmy, or ymd function is Coordinated Universal Time (UTC)

``` r
## creating a heterogeneous date object
library(lubridate)
hetero_date <- c("second chapter due on 2013, august, 24", "first chapter submitted on 2013, 08, 18", "2013 aug 23") 
ymd(hetero_date)
```

-   the sequence of year, month, and day should be similar across all values within the same object, otherwise during date extraction there will be a missing value that will be generated, along with a warning message.

## Text Manipulation

Besides default R functionality (`paste()`, `nchar()`, `substr()` ...) , there is one contributed package to deal with character data, which is more user friendly and intuitive: **stringr package**.

**Strings** can be arranged into **vectors and matrices** just like numbers. We can also paste strings together using `paste(..., sep)`. Here sep is an optional input, with default value " ", that determines which padding character is to be placed between the strings (which are input where ... appears).

*Example:*

```{r}
x <- "Citroen SM"
y <- "Jaguar XK150"
z <- "Ford Falcon GT-HO"
(wish.list <- paste(x, y, z, sep = ", "))
```

Special characters can be included in strings using the escape character `\`:

-   `\"` for "
-   `\n` for a newline
-   `\t` for a tab
-   `\b` for a backspace
-   `\\` for `\`

**Text data** can be used to retrieve information in sentiment analysis and even entity recognition.

### Sources of Text data

Text data can be found on tweets from any individual, or from any company, Facebook status updates, RSS feeds from any news site, Blog articles, Journal articles, Newspapers, Verbatim transcripts of an in-depth interview.

For example, t extract **Twitter data**, we can use `tweetR()` and, to extract data from **Facebook**, we could use `facebookR()`.

### Getting Text Data

The easiest way to get text data is to import from a .csv file where some of the variables contain character data. We have to protect automatic factor conversion by specifying the `stringsAsFactors = FALSE argument`

*Example 1:* The tweets.txt file is the plain text file. We will import this file using the generic `readLines()` function. It is a vector of characters (not a data.frame).

*Example 2:* Html (this is also a character string):

``` r
conURL <- "http://en.wikipedia.org/wiki/R_%28programming_language%29"
# Establish the connection with the URL 
link2URL <- url(conURL) 
# Reading html code
htmlCode <- readLines(link2URL)
# Closing the connection
close(link2URL)
# Printing the result 
htmlCode
```

The **tm** text mining library has some other functions to import text data from various files such as PDF files, plain text files, and even from doc files.

## Reshaping Datasets

Statistical analysis sometimes requires wide data and sometimes long data. In such cases, we need to be able to fluently and fluidly reshape the data to meet the requirements of statistical analysis.

Data reshaping is just a rearrangement of the form of the data---it does not change the content of the dataset.

*Example: reshape()*

``` r
students <- data.frame(sid=c(1,1,2,2), exmterm=c(1,2,1,2), math=c(50,65,75,69), 
literature=c(40,45,55,59), language=c(70,80,75,78))
# Reshaping dataset using reshape function to wide format
wide_students <- reshape(students, direction="wide", idvar="sid", timevar="exmterm")
# Now again reshape to long format
long_students <- reshape (wide_students, direction="long", idvar="id")
```

### The reshape package

-   Melting data (molten data)

    -   Though melting can be applied to different R objects, the most common use is to melt a data frame.
    -   To perform melting operations using the melt function, we need to know what the identification variables and measured variables in the original input dataset are.
    -   One important thing to note is that, whenever we use the melt function, all the measured variables should be of the same type, that is, the measured variables should be either numeric, factor, character, or date.
    -   To deal with the implicit missing value, it is good to use `na.rm = TRUE` with the melt function to remove the structural missing value (i.e., it will fill empty cells in the data table with NA).

    *Example:*

    ``` r
    ## the format of the resulting table is id/variable/value
    melt(students, id=c("sid","exmterm"), measured=c("math", "literature", "language"))
    ```

-   Casting molten data:

    -   Once we have molten data, we can rearrange it in any layout using the cast function from the reshape package.
    -   There are two main arguments required to cast molten data: data and formula.
    -   The basic casting formula is col_var_1+col_var_2 \~ row_var_1+ row_var_2, which describes the variables to appear in columns and rows.

    *Example:*

    ``` r
    # to return to the original data structure  
    cast(molten_students, sid+exmterm ~ variable)
    ```

-   For faster and large data rearrangement, use the **reshape2 package** and the functions `dcast` (data frames) and `acast` (arrays):

    *Example:*

    ``` r
    acast(molten_students, sid+exmterm~variable)
    ```
