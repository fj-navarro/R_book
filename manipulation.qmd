# Reading and Writing Data

## Reading Data

R provides a number of ways to read data from a file, the **most flexible** of which is the `scan()` function. We use scan to read a vector of values from a file. It has the form:

*Example:*

``` r
scan(file = "", what = 0, n = -1, sep = "", skip = 0, quiet = FALSE)
```

`scan()` returns a vector.

### Tabular data

It is common for data to be arranged in **tables**, with columns corresponding to variables and rows corresponding to separate observations. These **dataframes** are usually read into R using the function `read.table()`, which has the form:

``` r
read.table(file, header = FALSE, sep = "") 
# read.table() returns a dataframe
```

There are two commonly used **variants** of `read.table()`:

-   `read.csv()` is for comma-separated data and is equivalent to `read.table(file, header = TRUE, sep = ",")`

-   `read.delim()` is for tab-delimited data and is equivalent to`read.table(file, header = TRUE, sep = "\t")`.

*Example:*

``` r
## skips the first 2 lines
anscombe <- read.csv("CSVanscombe.csv", skip=2) 
```

If a **.csv file** contains both numeric and character variables, and we use `read.csv()`, the character variables get automatically converted to the **factor** type. We can prevent character variables from this automatic conversion to factor, by specifying `stringsAsFactors=FALSE` within the `read.csv()` function.

*Example:*

``` r
iris_b <- read.csv("iris.csv", stringsAsFactors=F)
```

Sometimes, it could happen that the file extension is **.csv**, but the data is **not comma separated**. In that case, we can still use the `read.csv()` function, but in this case we have to specify the separator:

*Example:*

``` r
read.csv("iris_semicolon.csv", stringsAsFactors = FALSE, sep=";")
anscombe_tab_2 <- read.table("anscombe.txt", header=TRUE)
```

Note that you can assign your **own column names** after reading the dataframe using the `names()` function, or when you read it in, using the `col.names` argument, which should be assigned a character vector the same length as the number of columns. If there is no header and no col.names argument, then R uses the names "V1", "V2", etc.

After reading the file, you can use the `head()` and `tail()` functions to examine the object:

*Example:*

``` r
head(ufc)
tail()
```

### Read line by line

Text files can be **read line by line** using the `readLines()` function:

*Example:*

``` r
con <- gzfile("words.gz") 
x <- readLines(con, 10)
```

This approach is useful because it allows you to read from a file **without having to uncompress the file first**, which would be a waste of space and time.

To read in lines of **webpages** it can be useful the `readLines()` function:

*Example:*

``` r
con <- url("http://www.jhsph.edu", "r") ## Read the web page 
x <- readLines(con) ## Print out the first few lines head(x)
```

### xls format

If the dataset is stored in the ***.xls or*** **.xlsx format** you can use `read.xlsx2`:

*Example:*

``` r
library(xlsx) 
anscombe_xlsx <- read.xlsx2("xlsxanscombe.xlsx", sheetIndex=1)
```

### RData format

If you need to store more than one dataset in a single file we can use the **\*.RData format**:

*Example:*

``` r
## example to load multiple datasets, and a vector of R objects from a single *.RData
load("robjects.RData")
## to check if objects have been loaded correctly
objects()
```

### Import Stata/SPSS file

To import a **Stata/SPSS file** into R:

-   First you need to call the foreign library:

    ``` r
    install.packages("foreign")
    ```

-   Then use `read.data()`/`read.spss()`:

    ``` r
    data <- read.spss(file="data.spss", to.data.frame=TRUE)
    ```

-   The output will always be a data frame:

    ``` r
    write.foreign(data, "mydata.txt", "mydata.sps", package="SPSS")
    ```

### JSON File

To read a **JSON file**:

``` r
install.packages("rjson") 
data <- fromJSON(file="data.json")
data2 <- as.data.frame(data)
```

### `view()`

To view the data variable, you can use the `view()`.

## Writing Data

R provides a number of commands for **writing** output to a file. You will generally use `write()` or `write.table()` for writing numeric values and `cat()` for writing text, or a combination of numeric and character values.

The command `write()` has the form:

``` r
write(x, file = "data", ncolumns = if(is.character(x)) 1 else 5, append = FALSE)
```

To write a **dataframe** to a file we use this:

``` r
write.table(x, file = "", append = FALSE, sep = " ", row.names = TRUE, col.names = TRUE)
```

Here `x` is the vector to be written. If `x` is a **matrix or array** then it is converted to a vector (column by column) before being written. The other parameters are optional.

We can identify the **complete rows** from a two-dimensional object such as a dataframe (that is, rows that have no missing values) via the `complete.cases` command. We can easily remove rows with missing values using the `na.omit` function.

### Writing Matrices

Because `write()` converts matrices to vectors before writing them, using it to write a matrix to a file can cause unexpected results. Since R stores its matrices by column, you should pass the **transpose of the matrix to write** if you want the output to reflect the matrix structure.

``` r
x <- matrix(1:24, nrow = 4, ncol = 6)
write(t(x), file = "../results/out.txt", ncolumns = 6)
```

### `cat()`

A more flexible command for writing to a file is `cat()`, which has the form:

``` r
cat(..., file = "", sep = " ", append = FALSE)
```

Note that cat does not automatically write a newline after the expressions *....* If you want a newline you must explicitly include the string `\n`.

### Tabular Data

For **writing tabular data** to text files (i.e. CSV) or connections you may use `write.table()`, which has this format:

*Example:*

``` r
write.table()
```

### `dump()`

There is also the very useful `dump()` function, which creates a text representation of almost any R object that can subsequently be read by source.

*Example:*

``` r
x <- matrix(rep(1:5, 1:5), nrow = 3, ncol = 5)
dump("x", file = "../results/x.txt")
rm(x)
source("../results/x.txt")
x
```

## Removing Duplicates

You can **remove duplicates** based on the `x` variable using:

``` r
x <- c(1, 2, NA, 4, NA, 5) 
data[!duplicated(data$x), ]
```

## Reshaping Datasets

Statistical analysis sometimes requires wide data and sometimes long data. In such cases, we need to be able to fluently and fluidly **reshape** the data to meet the requirements of statistical analysis. The function `reshape()` reshapes a dataframe between ‘wide’ format (with repeated measurements in separate columns of the same row) and ‘long’ format (with the repeated measurements in separate rows).

Data reshaping is just a rearrangement of the form of the data---it does not change the content of the dataset.

*Example:*

``` r
students <- data.frame(sid=c(1,1,2,2), exmterm=c(1,2,1,2), math=c(50,65,75,69), 
literature=c(40,45,55,59), language=c(70,80,75,78))

# Reshaping dataset using reshape function to wide format
wide_students <- reshape(students, direction="wide", idvar="sid", timevar="exmterm")

# Now again reshape to long format
long_students <- reshape (wide_students, direction="long", idvar="id")
```

### The reshape package

-   **Melting data (molten data)**:

    -   Though melting can be applied to different R objects, the most common use is to melt a data frame.
    -   To perform melting operations using the melt function, we need to know what the identification variables and measured variables in the original input dataset are.
    -   One important thing to note is that, whenever we use the melt function, all the measured variables should be of the same type, that is, the measured variables should be either numeric, factor, character, or date.
    -   To deal with the implicit missing value, it is good to use `na.rm = TRUE` with the melt function to remove the structural missing value (i.e., it will fill empty cells in the data table with NA).

    *Example:*

    ``` r
    ## the format of the resulting table is id/variable/value
    melt(students, id=c("sid","exmterm"), measured=c("math", "literature", "language"))
    ```

-   **Casting molten data**:

    -   Once we have molten data, we can rearrange it in any layout using the cast function from the reshape package.
    -   There are two main arguments required to cast molten data: data and formula.
    -   The basic casting formula is col_var_1+col_var_2 \~ row_var_1+ row_var_2, which describes the variables to appear in columns and rows.

    *Example:*

    ``` r
    # to return to the original data structure  
    cast(molten_students, sid+exmterm ~ variable)
    ```

-   For faster and large data rearrangement, use the **reshape2 package** and the functions `dcast` (data frames) and `acast` (arrays):

    *Example:*

    ``` r
    acast(molten_students, sid+exmterm~variable)
    ```
